---
id: 1756052520-deployment-of-spdhtc-using-existing-backup-database-file
alias: Deployment of SPDHTC using existing backup database file
tags: []
---
# Deployment of SPDHTC using existing backup database file

> [!NOTE]
> *Generated by gpt-5 (Thinking)*


Nice—here’s a tight first-boot + restore checklist for your setup with `spdhtc_1739675701.sql.gz` sitting in the host CWD (same folder as your compose file).

# First-time bring-up (prod)

1. **Create secrets (one line each, no trailing newline)**

```bash
mkdir -p secrets
printf 'super-strong-db-pass' > secrets/db_password.txt
printf 'even-stronger-root-pass' > secrets/db_root_password.txt
```

2. **Prepare `.env.production`** (must match the secret you used)

```dotenv
APP_ENV=production
APP_DEBUG=false
APP_URL=https://your-domain.tld
APP_KEY=base64:...            # generate once: php -r 'echo "base64:".base64_encode(random_bytes(32)).PHP_EOL;'

DB_CONNECTION=mysql
DB_HOST=db
DB_PORT=3306
DB_DATABASE=spdhtc
DB_USERNAME=spdhtc
DB_PASSWORD=super-strong-db-pass   # must equal secrets/db_password.txt contents
```

3. **Start only the DB** (let it initialize)

```bash
docker compose -f docker-compose.prod.yml up -d db
docker compose -f docker-compose.prod.yml ps db
```

4. **Restore the backup into MariaDB**

Option A (simple: copy into the container then import):

```bash
# copy the gz into the db container
docker compose -f docker-compose.prod.yml cp spdhtc_1739675701.sql.gz db:/tmp/restore.sql.gz

# import (reads the secret inside the container)
docker compose -f docker-compose.prod.yml exec -T db sh -lc \
  'gunzip -c /tmp/restore.sql.gz | mysql -u "$MYSQL_USER" -p"$(cat /run/secrets/db_password)" "$MYSQL_DATABASE"'

# quick smoke test
docker compose -f docker-compose.prod.yml exec -T db sh -lc \
  'mysql -u "$MYSQL_USER" -p"$(cat /run/secrets/db_password)" -e "SHOW TABLES" "$MYSQL_DATABASE" | head'
```

Option B (no copy; stream from host):

```bash
gunzip -c spdhtc_1739675701.sql.gz | docker compose -f docker-compose.prod.yml exec -T db sh -lc \
  'mysql -u "$MYSQL_USER" -p"$(cat /run/secrets/db_password)" "$MYSQL_DATABASE"'
```

5. **Bring up app + web (+ scheduler)**

```bash
docker compose -f docker-compose.prod.yml up -d app web scheduler
```

6. **Verify caches & health**

```bash
# entrypoint should have warmed caches
docker compose -f docker-compose.prod.yml logs --tail=50 app | grep -E 'warming Laravel caches|caches ready'

# FPM healthcheck (ping)
docker compose -f docker-compose.prod.yml ps app

# NGINX healthcheck
docker compose -f docker-compose.prod.yml ps web
curl -I http://127.0.0.1:${APP_PORT:-80}/
```

7. **First-run fixes (only if needed)**

```bash
# ensure storage perms (named volume can come up root-owned on first boot)
docker compose -f docker-compose.prod.yml exec -T app sh -lc \
  'mkdir -p storage/{app,framework/{cache,sessions,views},logs} && chown -R 82:82 storage'

# (optional) verify public symlink resolves
docker compose -f docker-compose.prod.yml exec -T web ls -l /var/www/html/public/storage
```

---

## Notes / gotchas

* You set `CACHE_ON_START=1` on **app** and `0` on **scheduler** — good. You already mounted a tmpfs at `/var/www/html/bootstrap/cache` for app, so cache warmups won’t hit read-only FS.
* I recommend **turning off** `MIGRATE_ON_START` by default in `app` for production (set to `0`) and running migrations as a **one-off** during deploys:

  ```bash
  docker compose -f docker-compose.prod.yml run --rm app php artisan migrate --force --no-ansi
  ```

  That avoids accidental concurrent migrations if you ever scale replicas.
* Make sure `DB_PASSWORD` in `.env.production` exactly matches `secrets/db_password.txt`. The DB container reads the secret file; the app reads the env var.

---

## One-shot helper (optional)

If you like repeatable restores, add this throwaway service and run it once:

```yaml
# append to docker-compose.prod.yml (services:)
  db-restore:
    image: mariadb:10.11
    depends_on:
      db: { condition: service_healthy }
    entrypoint: [ "sh", "-lc",
      "gunzip -c /restore/backup.sql.gz | mysql -h db -u $${MYSQL_USER} -p$$(cat /run/secrets/db_password) $${MYSQL_DATABASE}" ]
    environment:
      MYSQL_USER: ${DB_USERNAME:-spdhtc}
      MYSQL_DATABASE: ${DB_DATABASE:-spdhtc}
    volumes:
      - ./spdhtc_1739675701.sql.gz:/restore/backup.sql.gz:ro
    secrets: [ db_password ]
```

Run it once:

```bash
docker compose -f docker-compose.prod.yml run --rm db-restore
```

That’s it. Do the restore, flip services up, and you should be live with your imported data.
